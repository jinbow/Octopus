Cheat sheet for testing the code for incompressible transport scheme
#############################################

Exact analytical function
==========================

The code in this folder has been configured for the incompressible transport scheme for testing. Following these steps to run the test. 

1. The initial location of particles are generated by init_parti_xyz.py. There are four particles in the test. You can read the python script to understand the data structure and modify the initial positions and/or the number of particles. Let's denote the number of particles as npts.
1. Run the init_parti_xya.py from command line using 
    
    python init_parti_xya.py

   You will get a binary file named particle_init.bin, which can be changed as you want in init_parti_xya.py. This binary file will be used by the program for particle position initialization. The program will read data.nml to find this filename. So, if you change the filename, remember to change it in data.nml accordingly.

1. Now you have your particle initial locations. The next step is to compile the Octopus code. Run the following from the command line:
1.1 First step is to check cpp_options.h. Right now you do not have to do this step as I have set it up for you.
1.1. The second step is to change size.h for the grid size. I used nx=20, ny=20, but you can change it as you want. Remeber that the particle initial position is referenced to grid. The result is that the relative position for the same initial condition changes for different nx,ny, which is easy to understand, i.e., i(t=0)=1 is in the middle of the domain for nx=2 but near western boundary if nx=200. 

1. After the above steps, you are ready to compile. Run the following from the command line:

   make transport

   If sucessful, you will get a executable file named O.transport. 
1. Now you need to double check data.nml, the namelist file for setting up the parameters. As the first test, I have configured everything for a working code. You may want to change the following parameters in your tests:
    FnPartiInit: file name of the inital condition. You do not need to change it unless you have your reasons.  
    Npts: the number of particles. It needs to be the same as the number npts used in init_parti_xyz.py.
    dt: the time interval for rk4 integration. I used 1 second.
    tstart: the start time, default is 0
    tend: the end of the integration. I have set it to 72000 (20 hours) for the test. 
    SaveFreq: the output time interval. I used 1 min in this test case. 

1. Now run the code from the command line:
    
   ./O.transport

   You will see a list of diagnoses. After the program finishes, you will get a folder named "test" containing the output. This folder name can be changed in data.nml through  casename.  

1. In the output folder, the particle positions are saved in binary files for each output time step. To see the test result in this simple test case, run the following from command line:
    
   ./showit.sh

   You will see the figure similar to test/trajectory.png. This bash file runs two python programs. glue_opt_data.py combines all individual files into one with multiple time steps. p_xy.py visualized the trajectories. Be careful that if you have too many particles (>10k), the plotting of all trajecotries may take a long time. In such case, you can change p_xy.py to select a limited number of trajectories for visualization.   

1. The next step for you Paola is to check the unit. Specifically, if you want Lx=2000km, Ly=2000km to represent real ocean gyres, and Nx=20, Ny=20 for grid size 100km, the velocity should be in O(0.1 m/s) and the integration time tend should be years for a particle looping through a full gyre, approximately. The velocity subroutine is velocity_2D_exact.f90.



Discrete analytical 2D function
===============================

This code is configured for testing 2D velocity generated from an analytical function saved on a discretized grid. 

1. Generate velocity on a grid using velocity_2D_grid_save.f90. After changing its parameters, such as Nx,Ny,Lx,Ly etc., compile the file using 'gfortran velocity_2D_grid_save.f90'. You will get a 'a.out'. Run the program from command line using './a.out'. You will get velocity fields UVEL.data, VVEL.data and grid files DXG.data, DYG.data,DRF.data and hFacF.data.

1. Change Nx, Ny in size.h to match the Nx and Ny in velocity_2D_grid_save.f90. 

1. Compile Octopus using 'make' from command line. 

1. Open init_parti_xyz.py and change to initial particle as you like. Default at 40 particles along a horizontal line from the eastern boundary to the western boundary at j=50.

1. Generate initial particle using 'python init_parti_xyz.py' if you have changed the file. Otherwise, the initial file is already in this folder. 

1. Change data.nml as you like. 
   1. Make sure npts is equal to the number of particles generated by init_parti_xyz.py. 
   1. dt is the time step used in the rk4 integration. Smaller value leads to more accurate trajectories. Default is 1min .  
   1. Change the tend, i.e., the total running time. 
   1. saveFreq (in seconds), default is 2 hours. 
